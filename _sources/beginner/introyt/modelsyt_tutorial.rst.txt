.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_beginner_introyt_modelsyt_tutorial.py>` to download the full example code
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_beginner_introyt_modelsyt_tutorial.py:


`Introduction <introyt1_tutorial.html>`_ ||
`Tensors <tensors_deeper_tutorial.html>`_ ||
`Autograd <autogradyt_tutorial.html>`_ ||
**Building Models** ||
`TensorBoard Support <tensorboardyt_tutorial.html>`_ ||
`Training Models <trainingyt.html>`_ ||
`Model Understanding <captumyt.html>`_

Building Models with PyTorch
============================

Follow along with the video below or on `youtube <https://www.youtube.com/watch?v=OSqIP-mOWOI>`__.

.. raw:: html

   <div style="margin-top:10px; margin-bottom:10px;">
     <iframe width="560" height="315" src="https://www.youtube.com/embed/OSqIP-mOWOI" frameborder="0" allow="accelerometer; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
   </div>

``torch.nn.Module`` and ``torch.nn.Parameter``
----------------------------------------------

In this video, we’ll be discussing some of the tools PyTorch makes
available for building deep learning networks.

Except for ``Parameter``, the classes we discuss in this video are all
subclasses of ``torch.nn.Module``. This is the PyTorch base class meant
to encapsulate behaviors specific to PyTorch Models and their
components.

One important behavior of ``torch.nn.Module`` is registering parameters.
If a particular ``Module`` subclass has learning weights, these weights
are expressed as instances of ``torch.nn.Parameter``. The ``Parameter``
class is a subclass of ``torch.Tensor``, with the special behavior that
when they are assigned as attributes of a ``Module``, they are added to
the list of that modules parameters. These parameters may be accessed
through the ``parameters()`` method on the ``Module`` class.

As a simple example, here’s a very simple model with two linear layers
and an activation function. We’ll create an instance of it and ask it to
report on its parameters:



.. code-block:: default


    import torch

    class TinyModel(torch.nn.Module):
    
        def __init__(self):
            super(TinyModel, self).__init__()
        
            self.linear1 = torch.nn.Linear(100, 200)
            self.activation = torch.nn.ReLU()
            self.linear2 = torch.nn.Linear(200, 10)
            self.softmax = torch.nn.Softmax()
    
        def forward(self, x):
            x = self.linear1(x)
            x = self.activation(x)
            x = self.linear2(x)
            x = self.softmax(x)
            return x

    tinymodel = TinyModel()

    print('The model:')
    print(tinymodel)

    print('\n\nJust one layer:')
    print(tinymodel.linear2)

    print('\n\nModel params:')
    for param in tinymodel.parameters():
        print(param)

    print('\n\nLayer params:')
    for param in tinymodel.linear2.parameters():
        print(param)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The model:
    TinyModel(
      (linear1): Linear(in_features=100, out_features=200, bias=True)
      (activation): ReLU()
      (linear2): Linear(in_features=200, out_features=10, bias=True)
      (softmax): Softmax(dim=None)
    )


    Just one layer:
    Linear(in_features=200, out_features=10, bias=True)


    Model params:
    Parameter containing:
    tensor([[ 0.0705, -0.0377,  0.0797,  ..., -0.0432,  0.0340, -0.0893],
            [ 0.0811, -0.0505, -0.0111,  ..., -0.0204,  0.0922, -0.0802],
            [ 0.0141,  0.0723, -0.0608,  ..., -0.0479, -0.0580,  0.0233],
            ...,
            [-0.0786, -0.0224, -0.0270,  ...,  0.0295, -0.0247,  0.0359],
            [-0.0729,  0.0226, -0.0796,  ..., -0.0540,  0.0149,  0.0372],
            [ 0.0439,  0.0716, -0.0073,  ...,  0.0851,  0.0561, -0.0821]],
           requires_grad=True)
    Parameter containing:
    tensor([ 0.0162,  0.0717,  0.0296,  0.0685, -0.0515, -0.0115, -0.0695, -0.0253,
             0.0712, -0.0341,  0.0781,  0.0948, -0.0001,  0.0745,  0.0875, -0.0290,
             0.0516,  0.0432, -0.0126, -0.0271,  0.0882,  0.0646,  0.0401,  0.0915,
            -0.0557, -0.0332,  0.0856, -0.0589, -0.0583, -0.0934,  0.0897, -0.0009,
             0.0270, -0.0402,  0.0040, -0.0731,  0.0296, -0.0366, -0.0921, -0.0125,
            -0.0360, -0.0510, -0.0245, -0.0952, -0.0360,  0.0750, -0.0329,  0.0664,
            -0.0217, -0.0197,  0.0548,  0.0524,  0.0070,  0.0150,  0.0355, -0.0953,
            -0.0666, -0.0349, -0.0549,  0.0225, -0.0968,  0.0429, -0.0091, -0.0608,
             0.0841,  0.0754, -0.0061, -0.0263,  0.0786,  0.0848,  0.0953,  0.0764,
            -0.0820, -0.0185, -0.0583,  0.0378,  0.0152,  0.0803, -0.0637,  0.0406,
            -0.0283,  0.0912, -0.0756, -0.0389,  0.0849, -0.0622,  0.0653, -0.0089,
             0.0491, -0.0636, -0.0584,  0.0033,  0.0464, -0.0825, -0.0742, -0.0725,
            -0.0922,  0.0056,  0.0435,  0.0555,  0.0776,  0.0552,  0.0459, -0.0403,
            -0.0354, -0.0272, -0.0870,  0.0700, -0.0063,  0.0819,  0.0478, -0.0245,
             0.0288,  0.0876,  0.0249,  0.0160, -0.0278,  0.0976,  0.0788, -0.0838,
            -0.0641, -0.0946, -0.0858,  0.0880, -0.0332,  0.0520,  0.0869, -0.0504,
            -0.0386, -0.0364,  0.0818,  0.0778,  0.0143,  0.0677, -0.0582, -0.0570,
            -0.0121,  0.0570,  0.0732,  0.0908,  0.0363, -0.0859, -0.0476,  0.0357,
             0.0111, -0.0722,  0.0388, -0.0790, -0.0299,  0.0667, -0.0729,  0.0649,
             0.0107, -0.0489, -0.0749,  0.0363, -0.0170,  0.0194, -0.0616, -0.0580,
            -0.0369,  0.0981,  0.0538, -0.0313,  0.0151, -0.0027, -0.0344,  0.0958,
             0.0055, -0.0668,  0.0311,  0.0291, -0.0068,  0.0162, -0.0117,  0.0863,
            -0.0473, -0.0889, -0.0730, -0.0936,  0.0447, -0.0532, -0.0035, -0.0826,
            -0.0242,  0.0956,  0.0093,  0.0959, -0.0147, -0.0168, -0.0965, -0.0849,
            -0.0411, -0.0517, -0.0374,  0.0076,  0.0561,  0.0686, -0.0947,  0.0795],
           requires_grad=True)
    Parameter containing:
    tensor([[ 0.0686,  0.0265, -0.0347,  ...,  0.0384,  0.0060, -0.0076],
            [ 0.0609,  0.0077,  0.0010,  ...,  0.0367, -0.0252,  0.0062],
            [ 0.0104, -0.0341,  0.0679,  ..., -0.0612,  0.0391, -0.0524],
            ...,
            [-0.0554, -0.0319, -0.0042,  ..., -0.0499,  0.0151, -0.0686],
            [ 0.0445,  0.0269,  0.0418,  ..., -0.0153, -0.0679, -0.0689],
            [-0.0199,  0.0226, -0.0669,  ..., -0.0518,  0.0081,  0.0697]],
           requires_grad=True)
    Parameter containing:
    tensor([ 0.0398,  0.0558, -0.0034, -0.0132,  0.0615,  0.0574, -0.0143, -0.0586,
            -0.0656,  0.0631], requires_grad=True)


    Layer params:
    Parameter containing:
    tensor([[ 0.0686,  0.0265, -0.0347,  ...,  0.0384,  0.0060, -0.0076],
            [ 0.0609,  0.0077,  0.0010,  ...,  0.0367, -0.0252,  0.0062],
            [ 0.0104, -0.0341,  0.0679,  ..., -0.0612,  0.0391, -0.0524],
            ...,
            [-0.0554, -0.0319, -0.0042,  ..., -0.0499,  0.0151, -0.0686],
            [ 0.0445,  0.0269,  0.0418,  ..., -0.0153, -0.0679, -0.0689],
            [-0.0199,  0.0226, -0.0669,  ..., -0.0518,  0.0081,  0.0697]],
           requires_grad=True)
    Parameter containing:
    tensor([ 0.0398,  0.0558, -0.0034, -0.0132,  0.0615,  0.0574, -0.0143, -0.0586,
            -0.0656,  0.0631], requires_grad=True)


This shows the fundamental structure of a PyTorch model: there is an
``__init__()`` method that defines the layers and other components of a
model, and a ``forward()`` method where the computation gets done. Note
that we can print the model, or any of its submodules, to learn about
its structure.

Common Layer Types
------------------

Linear Layers
~~~~~~~~~~~~~

The most basic type of neural network layer is a *linear* or *fully
connected* layer. This is a layer where every input influences every
output of the layer to a degree specified by the layer’s weights. If a
model has *m* inputs and *n* outputs, the weights will be an *m*x*n*
matrix. For example:



.. code-block:: default


    lin = torch.nn.Linear(3, 2)
    x = torch.rand(1, 3)
    print('Input:')
    print(x)

    print('\n\nWeight and Bias parameters:')
    for param in lin.parameters():
        print(param)

    y = lin(x)
    print('\n\nOutput:')
    print(y)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Input:
    tensor([[0.5890, 0.2767, 0.8347]])


    Weight and Bias parameters:
    Parameter containing:
    tensor([[ 0.3576, -0.0344, -0.0744],
            [-0.0834, -0.4638,  0.5711]], requires_grad=True)
    Parameter containing:
    tensor([0.2284, 0.3923], requires_grad=True)


    Output:
    tensor([[0.3673, 0.6916]], grad_fn=<AddmmBackward0>)


If you do the matrix multiplication of ``x`` by the linear layer’s
weights, and add the biases, you’ll find that you get the output vector
``y``.

One other important feature to note: When we checked the weights of our
layer with ``lin.weight``, it reported itself as a ``Parameter`` (which
is a subclass of ``Tensor``), and let us know that it’s tracking
gradients with autograd. This is a default behavior for ``Parameter``
that differs from ``Tensor``.

Linear layers are used widely in deep learning models. One of the most
common places you’ll see them is in classifier models, which will
usually have one or more linear layers at the end, where the last layer
will have *n* outputs, where *n* is the number of classes the classifier
addresses.

Convolutional Layers
~~~~~~~~~~~~~~~~~~~~

*Convolutional* layers are built to handle data with a high degree of
spatial correlation. They are very commonly used in computer vision,
where they detect close groupings of features which the compose into
higher-level features. They pop up in other contexts too - for example,
in NLP applications, where the a word’s immediate context (that is, the
other words nearby in the sequence) can affect the meaning of a
sentence.

We saw convolutional layers in action in LeNet5 in an earlier video:



.. code-block:: default


    import torch.functional as F


    class LeNet(torch.nn.Module):

        def __init__(self):
            super(LeNet, self).__init__()
            # 1 input image channel (black & white), 6 output channels, 3x3 square convolution
            # kernel
            self.conv1 = torch.nn.Conv2d(1, 6, 5)
            self.conv2 = torch.nn.Conv2d(6, 16, 3)
            # an affine operation: y = Wx + b
            self.fc1 = torch.nn.Linear(16 * 6 * 6, 120)  # 6*6 from image dimension
            self.fc2 = torch.nn.Linear(120, 84)
            self.fc3 = torch.nn.Linear(84, 10)

        def forward(self, x):
            # Max pooling over a (2, 2) window
            x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2))
            # If the size is a square you can only specify a single number
            x = F.max_pool2d(F.relu(self.conv2(x)), 2)
            x = x.view(-1, self.num_flat_features(x))
            x = F.relu(self.fc1(x))
            x = F.relu(self.fc2(x))
            x = self.fc3(x)
            return x

        def num_flat_features(self, x):
            size = x.size()[1:]  # all dimensions except the batch dimension
            num_features = 1
            for s in size:
                num_features *= s
            return num_features








Let’s break down what’s happening in the convolutional layers of this
model. Starting with ``conv1``:

-  LeNet5 is meant to take in a 1x32x32 black & white image. **The first
   argument to a convolutional layer’s constructor is the number of
   input channels.** Here, it is 1. If we were building this model to
   look at 3-color channels, it would be 3.
-  A convolutional layer is like a window that scans over the image,
   looking for a pattern it recognizes. These patterns are called
   *features,* and one of the parameters of a convolutional layer is the
   number of features we would like it to learn. **This is the second
   argument to the constructor is the number of output features.** Here,
   we’re asking our layer to learn 6 features.
-  Just above, I likened the convolutional layer to a window - but how
   big is the window? **The third argument is the window or kernel
   size.** Here, the “5” means we’ve chosen a 5x5 kernel. (If you want a
   kernel with height different from width, you can specify a tuple for
   this argument - e.g., ``(3, 5)`` to get a 3x5 convolution kernel.)

The output of a convolutional layer is an *activation map* - a spatial
representation of the presence of features in the input tensor.
``conv1`` will give us an output tensor of 6x28x28; 6 is the number of
features, and 28 is the height and width of our map. (The 28 comes from
the fact that when scanning a 5-pixel window over a 32-pixel row, there
are only 28 valid positions.)

We then pass the output of the convolution through a ReLU activation
function (more on activation functions later), then through a max
pooling layer. The max pooling layer takes features near each other in
the activation map and groups them together. It does this by reducing
the tensor, merging every 2x2 group of cells in the output into a single
cell, and assigning that cell the maximum value of the 4 cells that went
into it. This gives us a lower-resolution version of the activation map,
with dimensions 6x14x14.

Our next convolutional layer, ``conv2``, expects 6 input channels
(corresponding to the 6 features sought by the first layer), has 16
output channels, and a 3x3 kernel. It puts out a 16x12x12 activation
map, which is again reduced by a max pooling layer to 16x6x6. Prior to
passing this output to the linear layers, it is reshaped to a 16 \* 6 \*
6 = 576-element vector for consumption by the next layer.

There are convolutional layers for addressing 1D, 2D, and 3D tensors.
There are also many more optional arguments for a conv layer
constructor, including stride length(e.g., only scanning every second or
every third position) in the input, padding (so you can scan out to the
edges of the input), and more. See the
`documentation <https://pytorch.org/docs/stable/nn.html#convolution-layers>`__
for more information.

Recurrent Layers
~~~~~~~~~~~~~~~~

*Recurrent neural networks* (or *RNNs)* are used for sequential data -
anything from time-series measurements from a scientific instrument to
natural language sentences to DNA nucleotides. An RNN does this by
maintaining a *hidden state* that acts as a sort of memory for what it
has seen in the sequence so far.

The internal structure of an RNN layer - or its variants, the LSTM (long
short-term memory) and GRU (gated recurrent unit) - is moderately
complex and beyond the scope of this video, but we’ll show you what one
looks like in action with an LSTM-based part-of-speech tagger (a type of
classifier that tells you if a word is a noun, verb, etc.):



.. code-block:: default


    class LSTMTagger(torch.nn.Module):

        def __init__(self, embedding_dim, hidden_dim, vocab_size, tagset_size):
            super(LSTMTagger, self).__init__()
            self.hidden_dim = hidden_dim

            self.word_embeddings = torch.nn.Embedding(vocab_size, embedding_dim)

            # The LSTM takes word embeddings as inputs, and outputs hidden states
            # with dimensionality hidden_dim.
            self.lstm = torch.nn.LSTM(embedding_dim, hidden_dim)

            # The linear layer that maps from hidden state space to tag space
            self.hidden2tag = torch.nn.Linear(hidden_dim, tagset_size)

        def forward(self, sentence):
            embeds = self.word_embeddings(sentence)
            lstm_out, _ = self.lstm(embeds.view(len(sentence), 1, -1))
            tag_space = self.hidden2tag(lstm_out.view(len(sentence), -1))
            tag_scores = F.log_softmax(tag_space, dim=1)
            return tag_scores








The constructor has four arguments:

-  ``vocab_size`` is the number of words in the input vocabulary. Each
   word is a one-hot vector (or unit vector) in a
   ``vocab_size``-dimensional space.
-  ``tagset_size`` is the number of tags in the output set.
-  ``embedding_dim`` is the size of the *embedding* space for the
   vocabulary. An embedding maps a vocabulary onto a low-dimensional
   space, where words with similar meanings are close together in the
   space.
-  ``hidden_dim`` is the size of the LSTM’s memory.

The input will be a sentence with the words represented as indices of
one-hot vectors. The embedding layer will then map these down to an
``embedding_dim``-dimensional space. The LSTM takes this sequence of
embeddings and iterates over it, fielding an output vector of length
``hidden_dim``. The final linear layer acts as a classifier; applying
``log_softmax()`` to the output of the final layer converts the output
into a normalized set of estimated probabilities that a given word maps
to a given tag.

If you’d like to see this network in action, check out the `Sequence
Models and LSTM
Networks <https://pytorch.org/tutorials/beginner/nlp/sequence_models_tutorial.html>`__
tutorial on pytorch.org.

Transformers
~~~~~~~~~~~~

*Transformers* are multi-purpose networks that have taken over the state
of the art in NLP with models like BERT. A discussion of transformer
architecture is beyond the scope of this video, but PyTorch has a
``Transformer`` class that allows you to define the overall parameters
of a transformer model - the number of attention heads, the number of
encoder & decoder layers, dropout and activation functions, etc. (You
can even build the BERT model from this single class, with the right
parameters!) The ``torch.nn.Transformer`` class also has classes to
encapsulate the individual components (``TransformerEncoder``,
``TransformerDecoder``) and subcomponents (``TransformerEncoderLayer``,
``TransformerDecoderLayer``). For details, check out the
`documentation <https://pytorch.org/docs/stable/nn.html#transformer-layers>`__
on transformer classes, and the relevant
`tutorial <https://pytorch.org/tutorials/beginner/transformer_tutorial.html>`__
on pytorch.org.

Other Layers and Functions
--------------------------

Data Manipulation Layers
~~~~~~~~~~~~~~~~~~~~~~~~

There are other layer types that perform important functions in models,
but don’t participate in the learning process themselves.

**Max pooling** (and its twin, min pooling) reduce a tensor by combining
cells, and assigning the maximum value of the input cells to the output
cell (we saw this). For example:



.. code-block:: default


    my_tensor = torch.rand(1, 6, 6)
    print(my_tensor)

    maxpool_layer = torch.nn.MaxPool2d(3)
    print(maxpool_layer(my_tensor))






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    tensor([[[0.1353, 0.4803, 0.0011, 0.3928, 0.9676, 0.8843],
             [0.3246, 0.6816, 0.3874, 0.0102, 0.2283, 0.4454],
             [0.7517, 0.0903, 0.9440, 0.9122, 0.3676, 0.7759],
             [0.7398, 0.9326, 0.3797, 0.8015, 0.2257, 0.0370],
             [0.5678, 0.3707, 0.7606, 0.9439, 0.6341, 0.9198],
             [0.4667, 0.6175, 0.8647, 0.7597, 0.5856, 0.2172]]])
    tensor([[[0.9440, 0.9676],
             [0.9326, 0.9439]]])


If you look closely at the values above, you’ll see that each of the
values in the maxpooled output is the maximum value of each quadrant of
the 6x6 input.

**Normalization layers** re-center and normalize the output of one layer
before feeding it to another. Centering the and scaling the intermediate
tensors has a number of beneficial effects, such as letting you use
higher learning rates without exploding/vanishing gradients.



.. code-block:: default


    my_tensor = torch.rand(1, 4, 4) * 20 + 5
    print(my_tensor)

    print(my_tensor.mean())

    norm_layer = torch.nn.BatchNorm1d(4)
    normed_tensor = norm_layer(my_tensor)
    print(normed_tensor)

    print(normed_tensor.mean())







.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    tensor([[[15.9048, 10.8296, 11.9572, 17.1524],
             [10.3306, 14.3989, 11.1188,  9.7173],
             [15.1544, 21.7027,  5.0241,  8.1078],
             [ 9.1728, 21.9357, 15.8983, 16.1002]]])
    tensor(13.4066)
    tensor([[[ 0.7375, -1.1881, -0.7603,  1.2109],
             [-0.5874,  1.6652, -0.1509, -0.9269],
             [ 0.4113,  1.4250, -1.1569, -0.6795],
             [-1.4616,  1.3631,  0.0269,  0.0716]]],
           grad_fn=<NativeBatchNormBackward0>)
    tensor(-2.1979e-07, grad_fn=<MeanBackward0>)


Running the cell above, we’ve added a large scaling factor and offset to
an input tensor; you should see the input tensor’s ``mean()`` somewhere
in the neighborhood of 15. After running it through the normalization
layer, you can see that the values are smaller, and grouped around zero
- in fact, the mean should be very small (> 1e-8).

This is beneficial because many activation functions (discussed below)
have their strongest gradients near 0, but sometimes suffer from
vanishing or exploding gradients for inputs that drive them far away
from zero. Keeping the data centered around the area of steepest
gradient will tend to mean faster, better learning and higher feasible
learning rates.

**Dropout layers** are a tool for encouraging *sparse representations*
in your model - that is, pushing it to do inference with less data.

Dropout layers work by randomly setting parts of the input tensor
*during training* - dropout layers are always turned off for inference.
This forces the model to learn against this masked or reduced dataset.
For example:



.. code-block:: default


    my_tensor = torch.rand(1, 4, 4)

    dropout = torch.nn.Dropout(p=0.4)
    print(dropout(my_tensor))
    print(dropout(my_tensor))






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    tensor([[[0.0000, 1.4423, 0.0000, 0.0000],
             [1.2319, 1.1891, 0.0163, 0.0000],
             [1.2465, 0.8491, 1.5773, 0.0000],
             [0.0000, 0.4356, 0.1661, 0.2062]]])
    tensor([[[1.6323e-01, 1.4423e+00, 1.0037e-03, 5.4936e-01],
             [0.0000e+00, 0.0000e+00, 1.6271e-02, 5.3051e-01],
             [0.0000e+00, 8.4915e-01, 0.0000e+00, 0.0000e+00],
             [1.1136e+00, 0.0000e+00, 0.0000e+00, 2.0617e-01]]])


Above, you can see the effect of dropout on a sample tensor. You can use
the optional ``p`` argument to set the probability of an individual
weight dropping out; if you don’t it defaults to 0.5.

Activation Functions
~~~~~~~~~~~~~~~~~~~~

Activation functions make deep learning possible. A neural network is
really a program - with many parameters - that *simulates a mathematical
function*. If all we did was multiple tensors by layer weights
repeatedly, we could only simulate *linear functions;* further, there
would be no point to having many layers, as the whole network would
reduce could be reduced to a single matrix multiplication. Inserting
*non-linear* activation functions between layers is what allows a deep
learning model to simulate any function, rather than just linear ones.

``torch.nn.Module`` has objects encapsulating all of the major
activation functions including ReLU and its many variants, Tanh,
Hardtanh, sigmoid, and more. It also includes other functions, such as
Softmax, that are most useful at the output stage of a model.

Loss Functions
~~~~~~~~~~~~~~

Loss functions tell us how far a model’s prediction is from the correct
answer. PyTorch contains a variety of loss functions, including common
MSE (mean squared error = L2 norm), Cross Entropy Loss and Negative
Likelihood Loss (useful for classifiers), and others.



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.059 seconds)


.. _sphx_glr_download_beginner_introyt_modelsyt_tutorial.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download

     :download:`Download Python source code: modelsyt_tutorial.py <modelsyt_tutorial.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: modelsyt_tutorial.ipynb <modelsyt_tutorial.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.readthedocs.io>`_
